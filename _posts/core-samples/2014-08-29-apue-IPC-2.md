
we looked at pipes, FIFOs, message queues, semaphores, and shared memory the
classical methods of IPC provided by various UNIX systems. These mechanisms
allow processes running on the same computer to communicate with one another.
In this chapter, we look at the mechanisms that allow processes running on
different computers (connected to a common network) to communicate with one
another—network IPC.

###Socket Descriptors

A socket is an abstraction of a communication endpoint.Just as they would use
file descriptors to access files, applications use socket descriptors to access
sockets. Socket descriptors are implemented as file descriptors in the UNIX System.

        #include <sys/socket.h>
        int socket(int domain, int type, int protocol);
                Returns: file (socket) descriptor if OK, −1 on error

        int shutdown(int sockfd, int how);
                Returns: 0 if OK, −1 on error

A SOCK_STREAM socket provides a byte-stream service; applications are unaware of
message boundaries. This means that when we read data from a SOCK_STREAM socket,
it might not return the same number of bytes written by the sender. We will
eventually get everything sent to us, but it might take several function calls.

A SOCK_SEQPACKET socket is just like a SOCK_STREAM socket except that we get a
message-based service instead of a byte-stream service. This means that the
amount of data received from a SOCK_SEQPACKET socket is the same amount as was
written. The Stream Control Transmission Protocol (SCTP) provides a sequential
packet service in the Internet domain.

A SOCK_RAW socket provides a datagram interface directly to the underlying
network layer (which means IP in the Internet domain). Applications are
responsible for building their own protocol headers when using this interface,
because the transport protocols (TCP and UDP, for example) are bypassed.
Superuser privileges are requiredto create a raw socket to prevent malicious
applications from creating packets that might bypass established security
mechanisms.

####why is shutdown needed?

First, close will deallocate the network endpoint only when the last active
reference is closed. If we duplicate the socket (with dup, for example), the
socket won’t be deallocated until we close the last file descriptor referring to
it. The shutdown function allows us to deactivate a socket independently of the
number of active file descriptors referencing it.

Second, it is sometimes convenient to shut a socket down in one direction only.
For example, we can shut a socket down for writing if we want the process we are
communicating with to be able to tell when we are done transmitting data, while
still allowing us to use the socket to receive data sent to us by the process.

###Address

####Byte Order

        #include <arpa/inet.h>
        uint32_t htonl(uint32_t hostint32)
            Returns: 32-bit integer in network byte order
        uint16_t htons(uint16_t hostint16);
            Returns: 16-bit integer in network byte order
        uint32_t ntohl(uint32_t netint32);
            Returns: 32-bit integer in host byte order
        uint16_t ntohs(uint16_t netint16);
            Returns: 16-bit integer in host byte order

####Address Formats
        #include <arpa/inet.h>
        const char *inet_ntop(int domain, const void *restrict addr,
                            char *restrict str,socklen_t size);
                Returns: pointer to address string on success, NULL on error

        int inet_pton(int domain, const char *restrict str,
                    void *restrict addr);
                Returns: 1 on success, 0 if the format is invalid, or −1 on error

####Address Lookup

        #include <netdb.h>
        struct hostent *gethostent(void);
                Returns: pointer if OK, NULL on error
        void sethostent(int stayopen);
        void endhostent(void);


        #include <netdb.h>
        struct netent *getnetbyaddr(uint32_t net, int type);
        struct netent *getnetbyname(const char *name);
        struct netent *getnetent(void);
                All return: pointer if OK, NULL on error
        void setnetent(int stayopen);
        void endnetent(void);

        //map between protocol names and numbers with the following functions
        #include <netdb.h>
        struct protoent *getprotobyname(const char *name);
        struct protoent *getprotobynumber(int proto);
        struct protoent *getprotoent(void);
                All return: pointer if OK, NULL on error
        void setprotoent(int stayopen);
        void endprotoent(void);


        #include <netdb.h>
        //map between a service name and a port
        struct servent *getservbyname(const char *name, const char *proto);
        struct servent *getservbyport(int port, const char *proto);

        //scan the services database sequentially
        struct servent *getservent(void);
                All return: pointer if OK, NULL on error
        void setservent(int stayopen);
        void endservent(void);

        //an application to map from a host name and a service name to an address, and vice versa
        #include <sys/socket.h>
        #include <netdb.h>
        int getaddrinfo(const char *restrict host,
                const char *restrict service,
                const struct addrinfo *restrict hint,
                struct addrinfo **restrict res);
                )
                Returns: 0 if OK, nonzero error code on error
        void freeaddrinfo(struct addrinfo *ai);
        const char *gai_strerror(int error);
                Returns: a pointer to a string describing the error

        int getnameinfo(const struct sockaddr *restrict addr, socklen_t alen,
                char *restrict host, socklen_t hostlen,
                char *restrict service, socklen_t servlen, int flags
                )
                Returns: 0 if OK, nonzero on error

 ####Associate an address with a socket
        //associate an address with a socket
        int bind(int sockfd, const struct sockaddr *addr, socklen_t len);
                Returns: 0 if OK, −1 on error

* The address we specify must be valid for the machine on which the process is
running; we can’t specify an address belonging to some other machine.

* The port number in the address cannot be less than 1,024 unless the process
has the appropriate privilege (i.e., is the superuser).

* Usually, only one socket endpoint can be bound to a given address, although
some protocols allow duplicate bindings.

For the Internet domain, if we specify the special IP address INADDR_ANY , the
socket endpoint will be bound to all the system’s network interfaces. This means
that we can receive packets from any of the network interface cards installed in
the system. the system will choose an address and bind it to our socket for us
if we call connect or listen without first binding an address to the socket.

        //discover the address bound to a socket
        int getsockname(int sockfd, struct sockaddr *restrict addr,
                        socklen_t *restrict alenp);
                Returns: 0 if OK, −1 on error

        //find out the peer’s address
        int getpeername(int sockfd, struct sockaddr *restrict addr,
                        socklen_t *restrict alenp);
                Returns: 0 if OK, −1 on error

###Connection Establishment

        int connect(int sockfd, const struct sockaddr *addr, socklen_t len);
                Returns: 0 if OK, −1 on error

                portable applications need to close the socket if connect fails. If
                we want to retry, we have to open a new socket.

        int listen(int sockfd, int backlog);
                Returns: 0 if OK, −1 on error

        int accept(int sockfd, struct sockaddr *restrict addr,
                socklen_t *restrict len);
                Returns: file (socket) descriptor if OK, −1 on error

###Data Transfer

Using read and write with socket descriptors is significant, because it means
that we can pass socket descriptors to functions that were originally designed
to work with local files.


        #include <sys/socket.h>
        ssize_t send(int sockfd, const void *buf, size_t nbytes, int flags);

If send returns success, it doesn’t necessarily mean that the process at the
other end of the connection receives the data. All we are guaranteed is that
when send succeeds, the data has been delivered to the network drivers without
error.

        ssize_t sendto(int sockfd, const void *buf, size_t nbytes, int flags,
                        const struct sockaddr *destaddr, socklen_t destlen);
                Returns: number of bytes sent if OK, −1 on error

        ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
                Returns: number of bytes sent if OK, −1 on error

sendmsg with a msghdr structure to specify multiple buffers from which
to transmit data
